inline int get(int x) {
  if (!m.count(x)) {
    int sz = sz(m);
    m[x] = sz;
  }
  return m[x];
}

void upd(int p, int inc) {
  int v = a[p];
  FOR(i, (p + BLOCK - 1) / BLOCK, N / BLOCK + 1) {
    CNT[i][cnt[i][v]]--;
    cnt[i][v] += inc;
    CNT[i][cnt[i][v]]++;
    int c = cnt[i][v];
    if (c > 0 && !in[i][c]) {
      in[i][c] = 1;
      con[i].pb(c);
    }
  }
}

inline int query2(int y) {
  int b = y / BLOCK;
  int ans = cnt[b][a[y]];
  FOR(i, BLOCK * b + 1, y + 1) ans += a[i] == a[y];
  return ans;
}

vi ok;
inline int query3(int y) {
  int mn = query2(y), ans = 0;
  int b = y / BLOCK;
  ok.clear();
  trav(i, con[b]) {
    if (!CNT[b][i]) {
      in[b][i] = 0;
      continue;
    }
    ok.pb(i);
    if (i >= mn)
      ans += CNT[b][i];
  }
  swap(con[b], ok);
  FOR(i, BLOCK * b + 1, y + 1) {
    cnt[b][a[i]]++;
    ans += cnt[b][a[i]] == mn;
  }
  FOR(i, BLOCK * b + 1, y + 1) cnt[b][a[i]]--;
  return ans;
}

// Rest of the code remains the same