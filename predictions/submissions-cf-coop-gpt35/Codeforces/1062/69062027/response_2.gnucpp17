#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

#define int long long
typedef long long ll;
typedef tree<int, null_type, less<int>, rb_tree_tag,
             tree_order_statistics_node_update>
    ordered_set;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int, int> pi;
typedef vector<pi> vpi;

#define mod 1000000007
#define dmp(x) cerr << "line " << __LINE__ << " " << #x << ":" << x << endl
#define fs first
#define sc second
#define pb push_back
#define all(c) (c).begin(), (c).end()
#define mt make_tuple

#define IOS                                                                    \
  ios::sync_with_stdio(0);                                                     \
  cin.tie(0);                                                                  \
  cout.tie(0)

template <class S, class T>
ostream &operator<<(ostream &o, const pair<S, T> &p) {
  return o << "(" << p.fs << "," << p.sc << ")";
}

template <class T> ostream &operator<<(ostream &o, const vector<T> &vc) {
  o << "{";
  for (const T &v : vc)
    o << v << ",";
  o << "}";
  return o;
}

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

struct HLD {
  vector<vector<int>> adj;
  int n, root, cnt;
  vector<int> sub, tin, tout, par, head, dep;
  int dfs1(int s, int p, int d) {
    par[s] = p;
    dep[s] = d;
    adj[s].erase(remove(adj[s].begin(), adj[s].end(), p), adj[s].end());
    for (auto &t : adj[s]) {
      sub[s] += dfs1(t, s, d + 1);
      if (sub[adj[s][0]] < sub[t]) swap(t, adj[s][0]);
    }
    return sub[s];
  }
  void dfs2(int s, int h) {
    head[s] = h;
    tin[s] = cnt++;
    for (auto t : adj[s]) {
      dfs2(t, t == adj[s][0] ? h : t);
    }
    tout[s] = cnt;
  }
  HLD(vector<vector<int>> &g, int rt)
      : adj(g), n(adj.size()), root(rt), cnt(0), sub(n, 1), tin(n), tout(n),
        par(n, -1), head(n), dep(n) {
    dfs1(root, -1, 0);
    dfs2(root, root);
  }
  int lca(int a, int b) {
    while (head[a] != head[b]) {
      if (dep[head[a]] > dep[head[b]]) swap(a, b);